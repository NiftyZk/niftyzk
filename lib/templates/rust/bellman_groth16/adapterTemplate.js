

const adapterFile = {
    name: "adapter.js",
    content: () => `import { utils, buildBn128, buildBls12381 } from "ffjavascript";
const { unstringifyBigInts } = utils;

async function getCurveFromName(name) {
    let curve;
    const normName = normalizeName(name);
    if (["BN128", "BN254", "ALTBN128"].indexOf(normName) >= 0) {
        curve = await buildBn128();
    } else if (["BLS12381"].indexOf(normName) >= 0) {
        curve = await buildBls12381();
    } else {
        throw new Error(\`Curve not supported: \${name}\`);
    }
    return curve;

    function normalizeName(n) {
        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join("");
    }

}

/**
 * The verification key adapter transforms the verification key into a format usable by the Bellman_ce based verifier
 * @param {string} verification_key_string - The verification_key.json as a string
 * @returns {string} uncompressed_vkey - Returns an uncompressed version of the verificaiton_key.json which can be parsed inside the rust verifier contract
 */
export async function verificationKeyAdapter(verification_key_string) {
    const verificationKey = JSON.parse(verification_key_string);

    //from object to u8 array
    const vkey = unstringifyBigInts(verificationKey)

    const curve = await getCurveFromName(vkey.curve);

    //Convert u8 array(little-endian order) to uncompressed type (big-endian) order and on bls12_318 curve
    //Which can be convert into Affine type in bellman

    const vk_alpha_1 = curve.G1.toUncompressed(curve.G1.fromObject(vkey.vk_alpha_1));
    const vk_beta_2 = curve.G2.toUncompressed(curve.G2.fromObject(vkey.vk_beta_2));
    const vk_gamma_2 = curve.G2.toUncompressed(curve.G2.fromObject(vkey.vk_gamma_2));
    const vk_delta_2 = curve.G2.toUncompressed(curve.G2.fromObject(vkey.vk_delta_2));

    let ic = [];

    for (let i = 0; i < vkey.IC.length; i++) {
        ic.push(Array.from(curve.G1.toUncompressed(curve.G1.fromObject(vkey.IC[i]))))
    }

    let uncompressed_vkey = {};

    uncompressed_vkey.alpha_1 = Array.from(vk_alpha_1);
    uncompressed_vkey.beta_2 = Array.from(vk_beta_2);
    uncompressed_vkey.gamma_2 = Array.from(vk_gamma_2);
    uncompressed_vkey.delta_2 = Array.from(vk_delta_2);
    uncompressed_vkey.ic = ic;


    return JSON.stringify(uncompressed_vkey)
}
/**
 * The proofAdapter adapts proofs generated with snarkjs into a format parsable by a bellman verifier.
 * Use this function on the front-end, to adapt proofs generated by the client for on-chain use
 * @param {string} verification_key_string - The contents of the verification_key.json as a string
 * @param {string} proof_string - The snarkjs generated proof as a string
 * @returns {string} - Returns the adapted proof to use inside rust bellman verifier
 */
export async function proofAdapter(verification_key_string, proof_string) {
    const verificationKey = JSON.parse(verification_key_string);

    //from object to u8 array
    const vkey = unstringifyBigInts(verificationKey)

    const pof = JSON.parse(proof_string);

    const proof = unstringifyBigInts(pof);
    const curve = await getCurveFromName(vkey.curve);

    // convert u8 array(little-endian order)to uncompressed type(big-endian order and on bls12_381 curve) 
    // which can be convert into Affine type in bellman
    const pi_a = curve.G1.toUncompressed(curve.G1.fromObject(proof.pi_a));
    const pi_b = curve.G2.toUncompressed(curve.G2.fromObject(proof.pi_b));
    const pi_c = curve.G1.toUncompressed(curve.G1.fromObject(proof.pi_c));

    let uncompressed_proof = {};
    uncompressed_proof.pi_a = Array.from(pi_a);
    uncompressed_proof.pi_b = Array.from(pi_b);
    uncompressed_proof.pi_c = Array.from(pi_c);

    return JSON.stringify(uncompressed_proof)
}

`
}

module.exports = { adapterFile }